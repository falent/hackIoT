"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const VirtualDeviceValidator_1 = require("./VirtualDeviceValidator");
class SequencedValidator extends VirtualDeviceValidator_1.VirtualDeviceValidator {
    executeSequence(sequence, result, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const virtualDevice = this.virtualDevice(sequence);
            yield virtualDevice.resetSession(sequence.locale);
            for (const test of sequence.tests) {
                try {
                    const resultItem = { test };
                    resultItem.status = "running";
                    const validator = new VirtualDeviceValidator_1.Validator(resultItem, undefined);
                    this.emit("message", undefined, validator.resultItem, context);
                    resultItem.actual = yield virtualDevice.message(test.input);
                    const errors = validator.check();
                    validator.resultItem.errors = errors;
                    if (validator.resultItem && errors.length === 0) {
                        validator.resultItem.result = "success";
                    }
                    else {
                        validator.resultItem.result = "failure";
                    }
                    validator.resultItem.status = "done";
                    result.tests.push(validator.resultItem);
                    this.emit("result", undefined, validator.resultItem, context);
                }
                catch (err) {
                    const resultItem = { test };
                    const validator = new VirtualDeviceValidator_1.Validator(resultItem, err);
                    validator.resultItem.result = "failure";
                    validator.resultItem.status = "done";
                    result.tests.push(validator.resultItem);
                    this.emit("result", undefined, validator.resultItem, context);
                }
            }
        });
    }
}
exports.SequencedValidator = SequencedValidator;
//# sourceMappingURL=SequencedValidator.js.map