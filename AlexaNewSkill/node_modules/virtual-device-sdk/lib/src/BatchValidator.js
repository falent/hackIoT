"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const VirtualDeviceValidator_1 = require("./VirtualDeviceValidator");
class BatchValidator extends VirtualDeviceValidator_1.VirtualDeviceValidator {
    executeSequence(sequence, result, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const virtualDevice = this.virtualDevice(sequence);
            yield virtualDevice.resetSession(sequence.locale);
            const messages = [];
            for (const test of sequence.tests) {
                messages.push(test.input);
            }
            let results;
            try {
                results = yield virtualDevice.batchMessage(messages);
            }
            catch (e) {
                result.result = "failure";
                result.errorMessage = e.toString();
                return;
            }
            for (let i = 0; i < sequence.tests.length; i++) {
                const test = sequence.tests[i];
                const resultItem = { test };
                resultItem.actual = results[i];
                const validator = new VirtualDeviceValidator_1.Validator(resultItem, undefined);
                const errors = validator.check();
                resultItem.errors = errors;
                if (errors.length === 0) {
                    resultItem.result = "success";
                }
                else {
                    resultItem.result = "failure";
                }
                validator.resultItem.status = "done";
                result.tests.push(resultItem);
                this.emit("result", undefined, validator.resultItem, context);
            }
        });
    }
}
exports.BatchValidator = BatchValidator;
//# sourceMappingURL=BatchValidator.js.map