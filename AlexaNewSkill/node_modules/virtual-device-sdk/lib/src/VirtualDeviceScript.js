"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const BatchValidator_1 = require("./BatchValidator");
const PrettyPrinter_1 = require("./PrettyPrinter");
const SequencedValidator_1 = require("./SequencedValidator");
const YAMLParser_1 = require("./YAMLParser");
const invocationNameRegexp = /(open|launch|tell|ask)(.*)$/;
const urlRegExp = /^https?:\/\//i;
class VirtualDeviceScript {
    constructor(token, userID, batch = false) {
        this.findReplaceMap = {};
        if (batch) {
            this.virtualDeviceValidator = new BatchValidator_1.BatchValidator(token, userID);
        }
        else {
            this.virtualDeviceValidator = new SequencedValidator_1.SequencedValidator(token, userID);
        }
    }
    findReplace(find, replace) {
        this.findReplaceMap[find] = replace;
    }
    locale(locale) {
        this.virtualDeviceValidator.locale(locale);
    }
    voiceID(voiceID) {
        return this.virtualDeviceValidator.voiceID(voiceID);
    }
    tests(scriptContents) {
        scriptContents = scriptContents.trim();
        scriptContents = this.tokenize(scriptContents);
        const sequences = [];
        let currentSequence = { tests: [], invocationName: "" };
        let sequence = 1;
        let sequenceIndex = 1;
        let absoluteIndex = 0;
        const utteranceTests = new YAMLParser_1.YAMLParser(scriptContents).parse();
        let utteranceCount = 0;
        let config = {};
        for (const utteranceTest of utteranceTests) {
            utteranceCount += 1;
            if (utteranceTest.name() === "config") {
                config = utteranceTest.object();
                continue;
            }
            if (!utteranceTest.isNull()) {
                absoluteIndex += 1;
                const input = utteranceTest.name();
                const test = {
                    absoluteIndex,
                    comparison: "contains",
                    expected: {},
                    input,
                    sequence,
                    sequenceIndex,
                };
                const expected = test.expected;
                if (utteranceTest.isString()) {
                    if (utteranceTest.isEmpty()) {
                        throw new Error("Line " + utteranceTest.line + ": No right-hand value specified.");
                    }
                    if (urlRegExp.test(utteranceTest.string())) {
                        expected.streamURL = utteranceTest.string();
                    }
                    else {
                        expected.transcript = utteranceTest.string();
                    }
                }
                else if (utteranceTest.isArray()) {
                    expected.transcript = utteranceTest.stringArray();
                }
                else if (utteranceTest.isObject()) {
                    test.expected = utteranceTest.object();
                }
                else if (utteranceTest.value() === undefined) {
                    throw new Error("Line " + utteranceTest.line + ": No properties added for object.");
                }
                currentSequence.tests.push(test);
                sequenceIndex += 1;
            }
            if (utteranceTest.isNull() || utteranceCount === utteranceTests.length) {
                if (currentSequence.tests.length) {
                    sequence += 1;
                    const firstInput = (currentSequence.tests
                        && currentSequence.tests.length > 0
                        && currentSequence.tests[0]
                        && currentSequence.tests[0].input) || "";
                    currentSequence.invocationName = this.detectInvocationName(firstInput);
                    if (config.voiceID) {
                        currentSequence.voiceID = config.voiceID;
                    }
                    if (config.locale) {
                        currentSequence.locale = config.locale;
                    }
                    sequences.push(Object.assign({}, currentSequence));
                    currentSequence = { tests: [], invocationName: "" };
                    sequenceIndex = 1;
                }
            }
        }
        return sequences;
    }
    executeDir(directoryPath) {
        return __awaiter(this, void 0, void 0, function* () {
            directoryPath = path.resolve(directoryPath);
            let stats;
            try {
                stats = fs.statSync(directoryPath);
            }
            catch (e) {
                return Promise.reject("Directory to execute does not exist: " + directoryPath);
            }
            if (!stats.isDirectory()) {
                return Promise.reject("Not a directory: " + directoryPath);
            }
            const items = fs.readdirSync(directoryPath);
            const results = {};
            for (const filePath of items) {
                if (filePath.endsWith(".yml") || filePath.endsWith(".yaml")) {
                    const fullPath = path.join(directoryPath, filePath);
                    const result = yield this.executeFile(fullPath);
                    results[fullPath] = result;
                }
            }
            return results;
        });
    }
    executeFile(filePath) {
        filePath = path.resolve(filePath);
        try {
            fs.statSync(filePath);
        }
        catch (e) {
            return Promise.reject("File to execute does not exist: " + filePath);
        }
        const fileContents = fs.readFileSync(filePath, "UTF-8");
        return this.execute(fileContents);
    }
    execute(scriptContents, context) {
        return this.virtualDeviceValidator.execute(this.tests(scriptContents), context);
    }
    validate(scriptContents) {
        try {
            this.tests(scriptContents);
            return undefined;
        }
        catch (err) {
            return err;
        }
    }
    prettifyAsPartialHTML(scriptContents, partialResultItems, includeTimeContent) {
        includeTimeContent = (typeof includeTimeContent !== "undefined") ? includeTimeContent : true;
        const virtualDeviceTestSequences = this.tests(scriptContents);
        const printer = new PrettyPrinter_1.PrettyPrinter();
        return printer.prettifyAsPartialHTML(virtualDeviceTestSequences, partialResultItems, includeTimeContent);
    }
    prettifyAsHTML(result, includeTimeContent) {
        const printer = new PrettyPrinter_1.PrettyPrinter();
        return printer.prettifyAsHTML(result, includeTimeContent);
    }
    on(event, cb) {
        this.virtualDeviceValidator.subscribe(event, cb);
    }
    off(event) {
        this.virtualDeviceValidator.unsubscribe(event);
    }
    checkAuth(scriptContents) {
        const sequences = this.tests(scriptContents);
        const promises = [];
        for (const sequence of sequences) {
            const promise = this.virtualDeviceValidator.checkAuth(sequence.invocationName);
            promises.push(promise);
        }
        return Promise.all(promises).then(() => "AUTHORIZED");
    }
    detectInvocationName(input) {
        const matches = input.toLowerCase().match(invocationNameRegexp);
        if (!matches || matches.length !== 3) {
            return "";
        }
        return matches[2].trim();
    }
    tokenize(script) {
        for (const find of Object.keys(this.findReplaceMap)) {
            const value = this.findReplaceMap[find];
            script = script.split(find).join(value);
        }
        return script;
    }
}
exports.VirtualDeviceScript = VirtualDeviceScript;
//# sourceMappingURL=VirtualDeviceScript.js.map