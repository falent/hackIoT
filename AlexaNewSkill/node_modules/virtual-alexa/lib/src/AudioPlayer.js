"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const AudioItem_1 = require("./AudioItem");
const SkillRequest_1 = require("./SkillRequest");
var AudioPlayerActivity;
(function (AudioPlayerActivity) {
    AudioPlayerActivity[AudioPlayerActivity["BUFFER_UNDERRUN"] = 0] = "BUFFER_UNDERRUN";
    AudioPlayerActivity[AudioPlayerActivity["FINISHED"] = 1] = "FINISHED";
    AudioPlayerActivity[AudioPlayerActivity["IDLE"] = 2] = "IDLE";
    AudioPlayerActivity[AudioPlayerActivity["PLAYING"] = 3] = "PLAYING";
    AudioPlayerActivity[AudioPlayerActivity["PAUSED"] = 4] = "PAUSED";
    AudioPlayerActivity[AudioPlayerActivity["STOPPED"] = 5] = "STOPPED";
})(AudioPlayerActivity = exports.AudioPlayerActivity || (exports.AudioPlayerActivity = {}));
class AudioPlayer {
    constructor(skillInstance) {
        this.skillInstance = skillInstance;
        this._emitter = null;
        this._playing = null;
        this._queue = [];
        this._activity = null;
        this._suspended = false;
        this._activity = AudioPlayerActivity.IDLE;
        this._emitter = new events_1.EventEmitter();
    }
    enqueue(audioItem, playBehavior) {
        if (playBehavior === AudioPlayer.PLAY_BEHAVIOR_ENQUEUE) {
            this._queue.push(audioItem);
        }
        else if (playBehavior === AudioPlayer.PLAY_BEHAVIOR_REPLACE_ALL) {
            if (this.isPlaying()) {
                this.playbackStopped();
            }
            this._queue = [];
            this._queue.push(audioItem);
        }
        else if (playBehavior === AudioPlayer.PLAY_BEHAVIOR_REPLACE_ENQUEUED) {
            this._queue = [];
            this._queue.push(audioItem);
        }
        if (!this.isPlaying()) {
            this.playNext();
        }
    }
    activity() {
        return this._activity;
    }
    playNext() {
        if (this._queue.length === 0) {
            return;
        }
        this._playing = this.dequeue();
        if (this._playing.stream.url.startsWith("http:")) {
            this.skillInstance.sessionEnded(SkillRequest_1.SessionEndedReason.ERROR, {
                message: "The URL specified in the Play directive must be HTTPS",
                type: "INVALID_RESPONSE",
            });
        }
        else {
            this.playbackStarted();
        }
    }
    suspend() {
        this._suspended = true;
        this.playbackStopped();
    }
    suspended() {
        return this._suspended;
    }
    playbackOffset(offset) {
        if (this.isPlaying()) {
            this.playing().stream.offsetInMilliseconds = offset;
        }
    }
    on(audioPlayerRequest, listener) {
        this._emitter.on(audioPlayerRequest, listener);
    }
    once(audioPlayerRequest, listener) {
        this._emitter.once(audioPlayerRequest, listener);
    }
    resume() {
        this._suspended = false;
        this.playbackStarted();
    }
    playbackNearlyFinished() {
        return this.audioPlayerRequest(SkillRequest_1.RequestType.AUDIO_PLAYER_PLAYBACK_NEARLY_FINISHED);
    }
    playbackFinished() {
        this._activity = AudioPlayerActivity.FINISHED;
        const promise = this.audioPlayerRequest(SkillRequest_1.RequestType.AUDIO_PLAYER_PLAYBACK_FINISHED);
        this.playNext();
        return promise;
    }
    playbackStarted() {
        this._activity = AudioPlayerActivity.PLAYING;
        return this.audioPlayerRequest(SkillRequest_1.RequestType.AUDIO_PLAYER_PLAYBACK_STARTED);
    }
    playbackStopped() {
        this._activity = AudioPlayerActivity.STOPPED;
        return this.audioPlayerRequest(SkillRequest_1.RequestType.AUDIO_PLAYER_PLAYBACK_STARTED);
    }
    playing() {
        return this._playing;
    }
    directivesReceived(directives) {
        for (const directive of directives) {
            this.handleDirective(directive);
        }
    }
    isPlaying() {
        return (this._activity === AudioPlayerActivity.PLAYING);
    }
    audioPlayerRequest(requestType) {
        const nowPlaying = this.playing();
        const serviceRequest = new SkillRequest_1.SkillRequest(this.skillInstance.context());
        serviceRequest.audioPlayerRequest(requestType, nowPlaying.stream.token, nowPlaying.stream.offsetInMilliseconds);
        return this.skillInstance.callSkill(serviceRequest);
    }
    handleDirective(directive) {
        if (directive.type === AudioPlayer.DIRECTIVE_PLAY) {
            const audioItem = new AudioItem_1.AudioItem(directive.audioItem);
            const playBehavior = directive.playBehavior;
            this.enqueue(audioItem, playBehavior);
        }
        else if (directive.type === AudioPlayer.DIRECTIVE_STOP) {
            if (this.suspended()) {
                this._suspended = false;
            }
            else if (this.playing()) {
                this.playbackStopped();
            }
        }
    }
    dequeue() {
        const audioItem = this._queue[0];
        this._queue = this._queue.slice(1);
        return audioItem;
    }
}
AudioPlayer.DIRECTIVE_PLAY = "AudioPlayer.Play";
AudioPlayer.DIRECTIVE_STOP = "AudioPlayer.Stop";
AudioPlayer.DIRECTIVE_CLEAR_QUEUE = "AudioPlayer.ClearQueue";
AudioPlayer.PLAY_BEHAVIOR_REPLACE_ALL = "REPLACE_ALL";
AudioPlayer.PLAY_BEHAVIOR_ENQUEUE = "ENQUEUE";
AudioPlayer.PLAY_BEHAVIOR_REPLACE_ENQUEUED = "REPLACE_ENQUEUED";
exports.AudioPlayer = AudioPlayer;
//# sourceMappingURL=AudioPlayer.js.map