"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const BuiltinUtterances_1 = require("./BuiltinUtterances");
class SampleUtterances {
    constructor() {
        this.samples = {};
    }
    static fromFile(file) {
        const data = fs.readFileSync(file);
        const utterances = new SampleUtterances();
        utterances.parseFlatFile(data.toString());
        return utterances;
    }
    static fromJSON(sampleUtterancesJSON) {
        const sampleUtterances = new SampleUtterances();
        for (const intent of Object.keys(sampleUtterancesJSON)) {
            for (const sample of sampleUtterancesJSON[intent]) {
                sampleUtterances.addSample(intent, sample);
            }
        }
        return sampleUtterances;
    }
    setInteractionModel(interactionModel) {
        this._interactionModel = interactionModel;
        const builtinValues = BuiltinUtterances_1.BuiltinUtterances.values();
        for (const key of Object.keys(builtinValues)) {
            if (this._interactionModel.hasIntent(key)) {
                for (const phrase of builtinValues[key]) {
                    this.addSample(key, phrase);
                }
            }
        }
    }
    interactionModel() {
        return this._interactionModel;
    }
    addSample(intent, sample) {
        if (!(intent in this.samples)) {
            this.samples[intent] = [];
        }
        this.samples[intent].push(new SamplePhrase(this, intent, sample));
    }
    samplesForIntent(intent) {
        let samples = [];
        if (intent in this.samples) {
            samples = this.samples[intent];
        }
        return samples;
    }
    defaultUtterance() {
        const firstIntent = Object.keys(this.samples)[0];
        return this.samples[firstIntent][0];
    }
    parseFlatFile(fileData) {
        const lines = fileData.split("\n");
        for (const line of lines) {
            if (line.trim().length === 0) {
                continue;
            }
            const index = line.indexOf(" ");
            if (index === -1) {
                throw Error("Invalid sample utterance: " + line);
            }
            const intent = line.substr(0, index);
            const sample = line.substr(index).trim();
            this.addSample(intent, sample);
        }
    }
}
exports.SampleUtterances = SampleUtterances;
class SamplePhrase {
    constructor(sampleUtterances, intent, phrase) {
        this.sampleUtterances = sampleUtterances;
        this.intent = intent;
        this.phrase = phrase;
        this.slotNames = [];
        this.phrase = phrase;
        this._regex = this.phraseToRegex(this.phrase);
    }
    slotName(index) {
        if (index >= this.slotNames.length) {
            return undefined;
        }
        return this.slotNames[index];
    }
    slotCount() {
        return this.slotNames.length;
    }
    regex() {
        return this._regex;
    }
    matchesUtterance(utterance) {
        return new SamplePhraseTest(this, utterance);
    }
    phraseToRegex(phrase) {
        const startIndex = phrase.indexOf("{");
        if (startIndex !== -1) {
            const endIndex = phrase.indexOf("}", startIndex);
            this.slotNames.push(phrase.substring(startIndex + 1, endIndex));
            phrase = phrase.substring(0, startIndex).trim() + "(.*)" + phrase.substring(endIndex + 1).trim();
            phrase = this.phraseToRegex(phrase);
        }
        return phrase.toLowerCase();
    }
}
exports.SamplePhrase = SamplePhrase;
class SamplePhraseTest {
    constructor(samplePhrase, utterance) {
        this.samplePhrase = samplePhrase;
        this.utterance = utterance;
        this.matched = false;
        const cleanUtterance = utterance.replace(/[^0-9a-zA-Z ]/g, "");
        const matchArray = cleanUtterance.match(samplePhrase.regex());
        this.matched = false;
        if (matchArray) {
            this.slotMatches = this.checkSlots(matchArray[0], matchArray.slice(1));
            if (this.slotMatches) {
                this.matched = true;
                this.matchString = matchArray[0];
            }
        }
    }
    matches() {
        return this.matched;
    }
    score() {
        let slotValueLength = 0;
        for (const slotValue of this.slotValues()) {
            slotValueLength += slotValue.length;
        }
        const score = this.matchString.length - slotValueLength;
        return score;
    }
    scoreSlots() {
        let typed = 0;
        for (const slotMatch of this.slotMatches) {
            if (!slotMatch.untyped) {
                typed++;
            }
        }
        return typed;
    }
    slotValues() {
        const values = [];
        for (const slotMatch of this.slotMatches) {
            values.push(slotMatch.slotValueName);
        }
        return values;
    }
    checkSlots(input, slotValues) {
        const result = [];
        let index = 0;
        for (const slotValue of slotValues) {
            if (input !== slotValue) {
                if (slotValue.trim().length > 0 && !slotValue.startsWith(" ") && !slotValue.endsWith(" ")) {
                    return undefined;
                }
            }
            const slotName = this.samplePhrase.slotName(index);
            const slotType = this.intentSchema().intent(this.samplePhrase.intent).slotForName(slotName);
            if (!slotType) {
                throw new Error("Invalid schema - not slot: " + slotName + " for intent: " + this.samplePhrase.intent);
            }
            const slotMatch = this.slotTypes().matchesSlot(slotType.type, slotValue);
            if (!slotMatch.matches) {
                return undefined;
            }
            else {
                result.push(slotMatch);
            }
            index++;
        }
        return result;
    }
    intentSchema() {
        return this.samplePhrase.sampleUtterances.interactionModel().intentSchema;
    }
    slotTypes() {
        return this.samplePhrase.sampleUtterances.interactionModel().slotTypes;
    }
}
exports.SamplePhraseTest = SamplePhraseTest;
//# sourceMappingURL=SampleUtterances.js.map